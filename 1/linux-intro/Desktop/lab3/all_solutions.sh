#
# 1)
grep "a" example.txt | tac
# греп выполняет поиск а tac выдает результат в обратном порядке
#
# 2) Объяснить
ls -y >> logfile 2>&1

#  -y - такого параметра нет у ls --> происходит ошибка
# поток ошибок(2) перенаправлен в общий вывод(&1)  2>&1
# общий вывод направлен в файл logfile, поэтому ошибка
# улетит туда же.
# после исполнения команды сообщение об ошибке записывается в logfile, в консоли ничего не выводится
#
#

# 3) 
head -n b+a filename | tail -n a
# Вывести a строк начиная с b'ой строки
# head - выводит верхнюю часть файла - b+a строк
# начиная с начала файла
# tail же выводит последние a строк уже обрубленного файла
# по сути отсекая b строк с начала
# после чего остаётся нужный фрагмент
#
# 4)
ls example.txt aboba 3>&1 1>&2 2>&3 | nl > error.log
# Файла aboba нет. 
# Создаём третий поток сразу отправляем его вывод в основной
# направляем вывод основного в поток ошибок
# а поток ошибок направляем в третий.
# таким образом тк 3 направлен в основной, то всё что будет проходить через третий можно направить через | в конце команды 
# в итоге ошибка которая возникает идёт сначала в третий а весь третий идёт в первый а весь первый идёт в nl и записывается в error.log
# а место куда раньше выводился поток ошибок свободно поэтому направленный туда основной вывод выходит в консоль
#
