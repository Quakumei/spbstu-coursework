/*
Динамическая память и управление ресурсами

Классы переменных:
- Автоматические - внутри функций циклов и тд тп.
Гарантируется, что будут уничтожены после того как закончится блок.
Для объектов - вызван деструктор. Инициализируются чем попало.

- Статические и глобальные
Статические бывают локальными (static у переменной).
Не умирает до конца программы. Сохраняет свое значение
между вызовами функции. В той же области памяти
хранятся глобальные переменные. По умолчанию глобальные
инициализируются нулями (0х00000000). Сначала инициализируются
константы, потом те, что возникают динамически. Порядок
инициализации переменных в различных единицах трансляции
не гарантируются. Поэтому не рекомендуется использование
глобальных переменных.

- Внешние (extern)
Объявлена, но определена в другом месте.

- Регистровые (register, не рекомендуется использовать)
Компилятор может игнорировать это ключевое слово.
Регистров не очень много. И вообще стало deprecated.


Динамическая память (heap)

Как это было в C:
void * malloc(size_t size); // - память ничем не инициализируется
void * calloc(size_t count, size_t); // - заполняет память нулями, и несколько сразу count*size памяти
void * realloc(void * ptr, size_t size);
// - позволяет перевыделить память. По возможности в том же месте и
//  выделится (большего размера).
// Если нет, то будет попытка перенести данные в новую память.
void free(void * ptr);

Параметр size - размер, единицей которого является размер типа char
malloc, calloc, realloc возвращаются NULL, если память не выделена

Но в C++ появились объекты, деструкторы, конструкоры, и появилась
необходимость в новых методах выделения памяти:
Операции происходят с (free store) - может совпадать с heap.

obj = new type;
obj_arr = new type[size]; // Конструктор для каждого объекта (как calloc)
delete obj;
delete[] obj_arr; // Деструктор для каждого объекта

Если память не сможет выделиться, то произойдет std::bad_alloc.
Но можно сделать так new (std::no_throw) type; - тогда будет nullptr в случае проблем

Placement new

Форма оператора new, которая позволяет разместить объект
указанного типа в уже выделенной области памяти

new (address) type

char buf[sizeof(Object)];
Object *obj = new (buf) Object(...);
obj -> ~Object();

К такому указателю delete применять нельзя.
Надо через деструктор. так как вызываться самостоятельно он не будет.


Проблемы динамической памяти

- Утчеки памяти
Необходимо всегда освобождать динамически выделенную память, тк при выходи
из локальной области видимости переменная-указатель уничтожается, а память, п
ривязнная к ней остаётся заполненной

- Повторное освобождение
Повтороное применение delete к ненулевому указателю вызовет исключение
(К нулевому указателю delete можно применять сколько угодно раз)

- Фрагментация памяти
В памяти будут промежутки как в сыре\

Чтобы бороться с фрагментацией существуют умные аллокаторы тд тп


Перегрузка new и delete()
- это не перегрузка операторов, слишком фундаментально для изменения
но можно перегрузить operator new() и operator delete() - отвечает только
за выделение памяти (часть оператора new).

Есть формы для массивов operator new[](), opeartor delete[]()

Будучи определнными в глобальном пространстве имен эти функции скрывают стандартные и позволяют управлять размещением даже значений базовых типов

Можно определить соответствующие методы для отдельных классов.


void * opeartor new(std)

*/

#include <iostream>
#include <array>
#include <algorithm>

class Foo
{
public:
    void *operator new(std::size_t size);
    void operator delete(void *ptr);
    static void printMemoryInfo(std::ostream &stream);

private:
    static const int MAX_COUNT = 10;
    static std::array<void *, MAX_COUNT> ptrs;
};
std::array<void *, Foo::MAX_COUNT> Foo::ptrs{nullptr};

void *Foo::operator new(std::size_t size)
{
    static int index = 0;
    if (index == MAX_COUNT)
    {
        throw std::bad_alloc();
    }
    void *ptr = std::malloc(size);
    if (!ptr)
    {
        throw std::bad_alloc();
    }
    ptrs[index++] = ptr;
    return ptr;
}

void Foo::operator delete(void *ptr)
{
    int index = std::distance(ptrs.begin(), std::find(ptrs.begin(), ptrs.end(), ptr));
    ptrs[index] = nullptr;
    free(ptr);
}

void Foo::printMemoryInfo(std::ostream &stream)
{
    for (auto p : ptrs)
    {
        if (p)
        {
            stream << "Address " << p << " is not deallocated";
        }
    }
}

int main()
{
    Foo *f1 = new Foo;
    Foo *f2 = new Foo;

    delete f1;

    Foo::printMemoryInfo(std::cout);
    return 0;
}

/*
Но это плохой дизайн, нарушает принцип
Один класс - одна обязанность



Копирование и присваивание обхъектов
class Object {};
void foo(Object arg){};

Object o1;
Object o2(o1); - копирование
Object o3 = o1; - копирование

foo(o1); - копирование
Object o4;
o4 = o1; -копирующее присваивание


Конструктор копирования
Object(const Object &other)
Автоматически определяется если нет конструктора копирования, перемещения, пермещающего присваивания
По умолчанию: вызвает конструкторы копирования всех базовых родительских классов
Копирует побитово поля встроенных типов
Вызывает конструкторы копирования для всех полей пользовательских типов


Оператор копирующего присваивания
Object & operator=(const Object & other)


Список инициализации вызвывается в том порядке, в котором они объявлены в классе


Гарантия безопасности исключений:
- Базовая гарантия - все ресурсы корректно освобождаются, объекты пригодны для дальнейшего использования, но их состояние может быть изменено.
- Строгая гарантия - состояние программы остается таким же, как до вызова метода, сгенерировавшего исключения (Хороший пример - идиома copy-and-swap для написания операторов присваивания)
- Гарантия отсутствия исключений - метод\функция ни при каких условиях не генерирует исключений. Такие методы необходим для обеспечения базовой и строгой гарантий.



Умные указатели
std::auto_ptr<> - устаревший
std::unique_ptr<> - передача владения происходит только при меремещении, копирование запрещено
Копирование невозможно. Мрожно только переместить ptr 2= std::move(ptr1);
Если в вызове создавтать указтели то возможно утчека. Решается с помощью
std::unique_ptr<Object> optr = std::make_unique<Object>();
Аналогично для shared_ptr<> имеется функция make_shared

std::shared_ptr<> -указатель с разделяемцым владением, уничттожение объекта происходит, когда исччезает последний указатель на него (используется счетчик ссылок)
Проблема - циклические ссылки и невозможность удалить объект

std::weak_ptr<>  вместо shared_ptr<>, чтобы не было проблемы с циклическими ссылками. но через weak ptr надо достучаться через lock(), напрямую нельзя

Было проедложено еще правило нуля - вообще не определять собственных конструкторов, делать их так, чтобы не были нужны
Т.е. использовать такие штуки, которые уже управляют памятью за вас.

Во многих случаях заместо обычного указателя предпочтительно использовать умный.



*/
